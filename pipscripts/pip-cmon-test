#! /bin/bash

MYNAME=$(basename $0)
MYDIR=$(dirname $0)
MYDIR=$(readlink -m $MYDIR)
VERSION="0.0.7"
VERBOSE=""
LOGFILE="$HOME/$MYNAME.log"
EXITCODE=0
COMMAND_LINE_OPTIONS="$0 $*"

GIT_HASH=""
GIT_BRANCH=""
GIT_AUTHOR=""
GIT_SUBJECT=""
START_EPOCH_TIME="$(date +%s)"

NO_GIT_PULL=""
OPTION_NO_COMPILE=""
OS_OPTION=""
OPTION_KEEP_NODES=""
DO_CLEAN=""

SHUT_DOWN_AFTER=""

OPTION_TEST_NAME=""
# May be empty would be better for vendor
VENDOR_OPTION=""
VERSION_OPTION=""
OPTION_USER="$USER"
OPTION_GIT_BRANCH=""
OPTION_GIT_COMMIT=""

declare -A REMOTE_SERVER_STATE

if [ -f "$MYDIR/load_config.sh" ]; then
    source $MYDIR/load_config.sh
else
    echo "File $MYDIR/load_config.sh was not found." >&2
    exit 5
fi

LOGFILE="$PROJECT_LOGDIR/$MYNAME.log"
echo "" >$LOGFILE

source $MYDIR/utilityfunctions.sh

if [ "${PROJECT_AUTO_PULL_WORKER}" != "true" ]; then
    NO_GIT_PULL="true"
fi

function printHelpAndExit()
{
cat <<EOF

Usage:
  $MYNAME [OPTION]...

  $MYNAME - Runs Cmon tests on multiple servers.

  -h, --help              Print this help and exit.
  -v, --version           Print version information and exit.
  --verbose               Print more messages.
  --log-file=FILE         Store all the messages in the given file too.
 
  --user=USERNAME         The name of the user requested the test.

  --pid                   Print the PID of the test script if it is running.
  
  --no-git-pull           Do not execute 'git pull' before the test.
  --no-compile            Do not compile the source, use as it is.
  --keep-nodes            Pass --keep-nodes to tests not to destroy containers.
  --shut-down-after       Shut down the test server after the test.
  --git-branch=BRANCH     The git branch to test.
  --git-commit=HASH       The git commit to test.

  --s9s                   Test the s9s project.
  --test=NAME             The name of the test to run.

  --sqlversion=VERSION    The version to test.
  --vendor=VENDOR         The vendor name to test.
  --os=OS                 The name of the OS to test.

EXAMPLE:
  $MYNAME --server=blade01 --os=debian8 --vendor=mariadb --sqlversion=5.6

EOF

  exit 0
}

ARGS=$(\
    getopt \
        -o hvj: \
        -l "help,verbose,version,log-file:,user:,server:,\
pid,\
test:,unit-tests,functional-tests,os:,vendor:,sqlversion:,s9s,\
no-git-pull,no-compile,keep-nodes,shut-down-after,wait,git-branch:,git-commit:" \
        -- "$@")

if [ $? -ne 0 ]; then
    exit 6
fi

eval set -- "$ARGS"
while true; do
    case "$1" in
        -h|--help)
            shift
            printHelpAndExit
            ;;

        --verbose)
            shift
            VERBOSE="true"
            VERBOSE_OPTION="--verbose"
            ;;

        -v|--version)
            shift
            printVersionAndExit
            ;;

        --log-file)
            shift
            LOGFILE=$(readlink -m "$1")
            shift
            ;;

        --keep-nodes)
            shift
            OPTION_KEEP_NODES="--keep-nodes"
            ;;

        --user)
            shift
            OPTION_USER="$1"
            shift
            ;;

        --test)
            shift
            OPTION_TEST_NAME="$1"
            shift
            ;;

        --os)
            shift
            OS_OPTION="--os=$1"
            shift
            ;;

        --vendor)
            shift
            VENDOR_OPTION="--vendor=$1"
            shift
            ;;
            
        --sqlversion)
            shift
            VERSION_OPTION="--provider-version=$1"
            shift
            ;;

        --no-git-pull)
            shift
            NO_GIT_PULL="true"
            ;;

        --no-compile)
            shift
            OPTION_NO_COMPILE="true"
            ;;

        --shut-down-after)
            shift
            SHUT_DOWN_AFTER="true"
            ;;

        --wait)
            shift
            WAIT_OPTION="--wait"
            ;;

        --git-branch)
            OPTION_GIT_BRANCH="$2"
            shift 2
            ;;

        --git-commit)
            OPTION_GIT_COMMIT="$2"
            shift 2
            ;;

        --)
            shift
            break
            ;;

        *)
            printVerbose "Unhandled option $1"
            printError "Unhandled option $1"
            exit 1
            ;;
    esac
done

#
# This is how we log from this script. Every run truncates the log file.
#
printVerbose "Starting test runner script..."
printVerbose "             TEST HOST: $(hostname)"
printVerbose "                MYNAME: $MYNAME"
printVerbose "                 MYDIR: $MYDIR"
printVerbose "  COMMAND_LINE_OPTIONS: $COMMAND_LINE_OPTIONS"
printVerbose "       TEST_REPORT_DIR: $PROJECT_TEST_REPORT_DIR"
printVerbose "     OPTION_GIT_BRANCH: $OPTION_GIT_BRANCH"
printVerbose "     OPTION_GIT_COMMIT: $OPTION_GIT_COMMIT"
printVerbose "                  date: $(date "+%Y-%m-%d %H:%M:%S")"

function changedir()
{
    local dir=$1
    printVerbose "cd $dir"
    cd $dir > /dev/null 2> /dev/null
    if [ $? -ne 0 ]; then
        printVerbose "Failed to change directory to $dir."
        return 1
    fi
    return 0
}

#
# $1: test name
#
function result_file_name_base()
{
    echo "${OPTION_TEST_NAME}-${GIT_BRANCH}-${GIT_HASH}"
}

#
# Copies the log file of this script to the test report directory
#
function save_to_results()
{
    local localfile="$1"
    local savedfile="${PROJECT_TEST_REPORT_DIR}/$2"

    if [ -f "$localfile" ]; then
        printVerbose "cp $localfile $savedfile"
        cp "$localfile" "$savedfile"
    else
        touch "$savedfile"
    fi
}

#
# Moves the log file of this script to the test report directory
#
function move_to_results()
{
    local source="$1"
    local dest="$2"

    save_to_results "$source" "$dest"

    printVerbose "rm -f $source"
    rm -f "$source"
}

#
# Copies the log file of this script to the test report directory
#
function save_slog_file()
{
    save_to_results "$LOGFILE" "$(result_file_name_base).slog"
}

#
# This expects to be in the source directory.
#
function prepare_source()
{
    local package_name="unknown"
    local current_branch
    local requested_branch
    local requested_commit
    local prompt="$USER@$HOSTNAME:$dirname\$"

    while [ -n "$1" ]; do
        case "$1" in 
            --package-name)
                package_name=$2
                shift 2
                ;;

            --requested-branch)
                requested_branch="$2"
                shift 2
                ;;

            --requested-commit)
                requested_commit="$2"
                shift 2
                ;;

            *)
                break
                ;;
        esac
    done

    if [ -z "$NO_GIT_PULL" ]; then
        printVerbose "Pulling source for $package_name."
        
        printVerbose "Pulling in directory '${PWD}'"
        git reset --hard HEAD >/dev/null 2>/dev/null
        git pull >/dev/null 2>/dev/null

        #
        # Checking the branch.
        #
        current_branch=$(git rev-parse --abbrev-ref HEAD)
        printVerbose "Current branch is '$current_branch'."
       
        if [ -z "$requested_branch" ]; then
            printVerbose "Requested branch is not set, using 'master'."
            requested_branch="master"
        else 
            printVerbose "Requested branch is '$requested_branch'."
        fi

        #if [ "$current_branch" != "$requested_branch" ]; then
        #    printVerbose "$prompt git checkout $requested_branch"
        #    git checkout "$requested_branch" >>$LOGFILE 2>>$LOGFILE
        #fi
        
        printVerbose "$prompt git fetch --all"
        git fetch --all >>$LOGFILE 2>>$LOGFILE

        # always reset any local changes first, then go to master
        printVerbose "$prompt git reset --hard"
        git reset --hard >>$LOGFILE 2>>$LOGFILE

        printVerbose "$prompt git checkout master"
        git checkout master >>$LOGFILE 2>>$LOGFILE

        if [ "$requested_branch" != "master" ]; then
            # first delete any local branch with the same name
            # (as the remote branch might be overwritten from stratch)
            printVerbose "$prompt git branch -d $requested_branch"
            git branch -d $requested_branch >>$LOGFILE 2>>$LOGFILE

            # and lets check out the branch now
            # (it will be re-constructed from remote)
            printVerbose "$prompt git checkout $requested_branch"
            git checkout $requested_branch >>$LOGFILE 2>>$LOGFILE
        fi

        printVerbose "$prompt git pull"
        printVerbose "Pulling in directory '${PWD}'"
        git pull >>$LOGFILE 2>>$LOGFILE

        if [ ! -z "$requested_commit" ]; then
            printVerbose "$prompt git checkout $requested_commit"
            git checkout $requested_commit >>$LOGFILE 2>>$LOGFILE
        fi

        # Files are left everywhere... :(
        if [ -d "./tests/configs/tls" ]; then
            rm -rvf "./tests/configs/tls"
        fi
    fi

    if [ "$DO_CLEAN" ]; then
        printVerbose "Cleaning source dir."

        git clean -dfx >/dev/null 2>/dev/null
    fi
}

function find_mysql()
{
    for dir in /opt/mysql-cluster-gpl-7*; do
        if [ -d "$dir" ]; then
            echo "$dir"
            return 0
        fi
    done

    return 1
}

#
# Expects to be in the source directory.
#
function compile_source_dir()
{
    local mysql_dir=$(find_mysql)    
    local do_install
    local prefix_option=""
    local cmon=false

    while [ -n "$1" ]; do
        case "$1" in 
            --prefix)
                prefix_option="--prefix=$2"
                shift 2
                ;;

            --cmon-compilation)
                cmon=true
                shift
                ;;

            --install)
                do_install="true"
                shift
                ;;

            *)
                break
                ;;
        esac
    done

    if [ "$mysql_dir" ]; then
        export PATH="$mysql_dir/bin:$PATH"
    fi

    save_slog_file

    #
    # Not gonna compile the source when the --no-compile command line option is
    # provided.
    #
    if [ "$OPTION_NO_COMPILE" ]; then
        return 0
    fi

    #
    # Hack to avoid compilation
    #
    if [ cmon ]; then
        case "$OPTION_TEST_NAME" in 
            ft_*.sh)
                repodir="$HOME/ft_full_repo/$OPTION_GIT_BRANCH-$OPTION_GIT_COMMIT"
                ccdir="${PROJECT_CC_WORKER_DIR}"

                if [ -d "$repodir" ]; then
                    printVerbose "Using previously compiled ft_full from $repodir"
                    cp $repodir/ft_full $ccdir/tests/ft_full/
                    return
                fi
            ;;
            *)
                # Nothing to do here
            ;;
        esac
    fi

    #
    # Running autogen in the source root. 
    #
    if [ ! -f "Makefile" ]; then
        printVerbose "Running autogen.sh."

        rm -f autogen.log

        if [ cmon ]; then
            ./autogen.sh --with-no-optimization $prefix_option >> "autogen.log" 2>>"autogen.log"
        else
            ./autogen.sh $prefix_option >> "autogen.log" 2>>"autogen.log"
        fi
        retcode $?
        if [ $retcode -ne 0 ]; then
            printVerbose "Script autogen.sh failed."
            return 6
        fi
    fi
    
    #
    # Running make in source root.
    #
    printVerbose "Running 'make'."

    rm -f "make.log"

    make -j10 >>"make.log" 2>>"make.log"
    retcode=$?
    make -j10
    if [ "$retcode" -ne 0 ]; then
        printVerbose "Program 'make' failed."
        tail -n 50 "$PWD/make.log" >>$LOGFILE

        return 1
    fi

    # Lets compile in the tests dir as well in case only some test changed.

    cd tests
    make -j10 >>"make.log" 2>>"make.log"
    retcode=$?
    make -j10
    if [ "$retcode" -ne 0 ]; then
        printVerbose "Program 'make' failed."
        tail -n 50 "$PWD/make.log" >>$LOGFILE
        cd ..
        return 1
    fi
    cd ..


    if [ -n "$do_install" ]; then
        printVerbose "Running 'make install'."

        sudo make install >>"make.log" 2>>"make.log"

        if [ $? -ne 0 ]; then
            printVerbose "Installing with 'make install' failed."
            return 1
        fi
    fi

    #
    # Hack to cache ft_full avoid compilation next time
    #
    if [ cmon ]; then
        case "$OPTION_TEST_NAME" in 
            ft_*.sh)
                repodir="$HOME/ft_full_repo/$OPTION_GIT_BRANCH-$OPTION_GIT_COMMIT"
                ccdir="${PROJECT_CC_WORKER_DIR}"

                mkdir -p "$repodir"
                printVerbose "Saving ft_full to $repodir"
                cp $ccdir/tests/ft_full/ft_full $repodir/
            ;;
            *)
                # Nothing to do here
            ;;
        esac
    fi

    return 0
}

function compile_source()
{
    local retcode

    printVerbose "Preparing clustercontrol"

    #
    # Compiling the controller.
    # The source is already prepared in advance.
    #

    pip-host-control --testing --status="Compiling CC for $OPTION_TEST_NAME"

    changedir "${PROJECT_CC_WORKER_DIR}"
    compile_source_dir \
        --cmon-compilation

        #--prefix=$HOME/testcmon
        #--prefix=$HOME/cmonrepo/$GIT_BRANCH-$GIT_HASH

    retcode=$?
    
    if [ "$retcode" -ne 0 ]; then
        printVerbose "The return code is $retcode..."
        return "$retcode"
    fi

    #
    # Compiling the s9s-tools, the source is not yet prepared.
    #

    pip-host-control --testing --status="Compiling s9s for $OPTION_TEST_NAME"

    changedir "${PROJECT_S9S_WORKER_DIR}"
    prepare_source \
        --package-name "s9s-tools"

    compile_source_dir \
        --install 

        #--prefix=$HOME/tests9s

    retcode="$?"

    return "$retcode"
}

#
# $1: test name
#
# The report is a HTML file where we put the report about the test run.
#
function report_file_name()
{
    echo "$(result_file_name_base).html"
}

function result_file_name()
{
    echo "$(result_file_name_base).result"
}

function log_bin_file_name()
{
    echo "$(result_file_name_base).ft_full"
}

function log_core_file_name()
{
    echo "$(result_file_name_base).core"
}

function log_file_name()
{
    echo "$(result_file_name_base).log"
}

function daemon_log_file_name()
{
    echo "$(result_file_name_base).dlog"
}

function ft_test_ended()
{
    local exit_code="$1"
    local backend_pid="$2"
    local core_file

    #printVerbose "<h2>Backtrace</h2>" 

    printVerbose "The test ended."
    printVerbose "  exit_code: $exit_code"
    printVerbose "         wd: '$PWD'"

    pip-host-control --testing --status="Finishing $OPTION_TEST_NAME"

    #for core_file in \
    #    *core* \
    #    */*core* \
    #    ${PROJECT_CC_WORKER_DIR}/*core* \
    #    ${PROJECT_CC_WORKER_DIR}/tests/*core* \
    for core_file in \
        /tmp/*.core;
    do
        if [ ! -f "$core_file" ]; then
            continue
        fi

        printVerbose "Core file found: $core_file"
    done

    if [ ! -f "$core_file" -a "$exit_code" -eq 0 ]; then
        return 0
    fi

    if [ -z "$(which gdb)" ]; then
        printVerbose "Installing gdb."
        sudo apt-get -y --force-yes install gdb
    fi

    if [ -e "$core_file" ]; then
        printVerbose "Saving backtrace (crash)"
        sudo gdb \
            -batch \
            -ex "thread apply all back" \
            -ex "quit" \
            ft_full/ft_full "$core_file" \
            >>$LOGFILE 2>>$LOGFILE

        sudo mkdir -p "$HOME/tmp"

        #sudo mv "$core_file" "/tmp/$(log_core_file_name)"
        #sudo chown $USER:$USER "/tmp/$(log_core_file_name)"
        #move_to_results "/tmp/$(log_core_file_name)" "$(log_core_file_name)"
        move_to_results "$core_file" "$(log_core_file_name)"

        move_to_results "${PROJECT_CC_WORKER_DIR}/tests/ft_full/ft_full" \
                        "$(log_bin_file_name)"

    elif [ -n "$backend_pid" -a "$exit_code" -ne 0 ]; then
        printVerbose "Saving backtrace (no crash)"
        sudo gdb \
            -p $backend_pid -batch \
            -ex "thread apply all back" \
            -ex "quit" \
            >>$LOGFILE 2>>$LOGFILE
    else
        printVerbose "No backtrace is necessary. No crash, no error on exit."
    fi
}

function save_report_file_ascii()
{
    local report_file=$(report_file_name)
    local tmp_file="/var/tmp/$report_file"

    cat <<EOF >>$tmp_file
    <html>
      <h1>Test results for '$1'</h1>
      <p>This test created no report. Try to check the programs output for
      details. The web interface shows the output when clicked on the test's
      name.</p>
    </html>
EOF

    move_to_results "$tmp_file" "$report_file"
}

#
# $2: the state, "FAILURE", "RUNNING" or "SUCCESS"
#
function upload_result_file()
{
    local test_state
    local unit_test_option
    local functional_test_option
    local pid_to_watch
    local counter

    while true; do
        case "$1" in 
            --unit-test)
                shift
                unit_test_option="--unit-test"
                ;;

            --functional-test)
                shift
                functional_test_option="--functional-test"
                ;;

            --pid)
                shift
                pid_to_watch="$1"
                shift
                ;;

            *)
                break
        esac
    done

    test_state="$1"


    #
    # If we have a PID we do the uploading until that ends. If not, we just
    # upload once.
    #
    counter=0

    while true; do
        save_report_file_ascii

        generate_test_result_info \
            $unit_test_option \
            $functional_test_option \
            --test-state "$test_state" \
            > "${PROJECT_TEST_REPORT_DIR}/$(result_file_name)"

        if [ -z "$unit_test_option" -a \
            -f "${PROJECT_CC_WORKER_DIR}/tests/ft_full.log" ]; then
            save_to_results "${PROJECT_CC_WORKER_DIR}/tests/ft_full.log" "$(daemon_log_file_name)"
        fi

        if [ -z "$pid_to_watch" ]; then
            break
        fi

        if ! ps --pid $pid_to_watch; then
            break
        fi

        # We are not gonna run indefinitely, that is a huge disaster.
        let counter+=10
        if [ $counter -gt 5400 ]; then
            printVerbose "One and a half hour elapsed, the watcher will abort now."
            break
        fi

        sleep 10
    done
}

function elapsedTimeString()
{
    local start_date="$1"
    local end_date="$(date +%s)"
    local T=$((end_date-start_date))

    printf "%02d:%02d:%02d" \
        "$((T/3600%24))" "$((T/60%60))" "$((T%60))"
}

function generate_test_result_info()
{
    local git_has_local_changes="no"
    local elapsed_time
    local is_unit_test="true"
    local test_state

    while true; do
        case "$1" in 
            --unit-test)
                shift
                is_unit_test="true"
                ;;

            --functional-test)
                shift
                is_unit_test="false"
                ;;

            --test-state)
                shift
                test_state="$1"
                shift
                ;;

            *)
                break
        esac
    done

    git_has_local_changes="no"

    if ! git diff-index --quiet HEAD --; then 
        git_has_local_changes="yes"
    fi

    elapsed_time="$(date +%s)"
    let elapsed_time-="$START_EPOCH_TIME"

    cat <<EOF
test_server="$(hostname)"
testname="$OPTION_TEST_NAME"
githash="$GIT_HASH"
gitbranch="$GIT_BRANCH"
gitcommitdate="$GIT_COMMIT_DATE"
githaslocalchanges="$git_has_local_changes"
state="$test_state"
report_file="$(report_file_name)"
user="$OPTION_USER"
elapsed_time="$elapsed_time"
elapsed_time_string="$(elapsedTimeString $START_EPOCH_TIME)"
test_start_epoch="$START_EPOCH_TIME"
is_unit_test="$is_unit_test"
EOF
}

function run_test()
{
    local return_code
    local logfile

    logfile="${PROJECT_TEST_REPORT_DIR}/$(log_file_name)"

    #
    # Notifying the user about a test is starting.
    #
    printVerbose "Preparing to run $OPTION_TEST_NAME."
    save_slog_file

    printVerbose "Enabling core file creation."
    echo "core" | sudo tee /proc/sys/kernel/core_pattern >> $LOGFILE 2>> $LOGFILE
    if [ $? -ne 0 ]; then
        printVerbose "Failed: echo 'core' | sudo tee /proc/sys/kernel/core_pattern"
    fi

    for core_file in \
        /tmp/*.core \
        *core* \
        */*core* \
        ${PROJECT_CC_WORKER_DIR}/*core* \
        ${PROJECT_CC_WORKER_DIR}/tests/*core*; 
    do
        if [ ! -f "$core_file" ]; then
            continue
        fi

        rm -f "$core_file"
    done

    ulimit -c unlimited
    if [ $? -ne 0 ]; then
        printVerbose "Failed: ulimit -c unlimited"
    fi

    sudo sysctl -p /etc/sysctl.conf
    printVerbose "Core pattern: $(sudo cat /proc/sys/kernel/core_pattern)"
    printVerbose ""
    printVerbose "User limits :"
    printVerbose ""
    bash -c 'ulimit -a' >> $LOGFILE 2>> $LOGFILE
    printVerbose ""
    printVerbose "User limits with sudo:"
    printVerbose ""
    sudo bash -c 'ulimit -c unlimited' >> $LOGFILE 2>> $LOGFILE
    sudo bash -c 'ulimit -a' >> $LOGFILE 2>> $LOGFILE

    #
    # Running the actual test.
    #
    printVerbose "PWD: $(pwd)"
    printVerbose "Test name is '${OPTION_TEST_NAME}'."
    case "$OPTION_TEST_NAME" in 
        ft_*.sh)
            #
            # Running the ft_full
            #
            export DOWNLOAD_KEYSERVER="hkp://keyserver.ubuntu.com"
            changedir "${PROJECT_CC_WORKER_DIR}/tests"

            if [ -x "./ft_full/ft_full" ]; then
                printVerbose "Running 'ft_full'..."

                printVerbose "Current directory: $(pwd)"
                printVerbose "Sudo environment: $(sudo env)"

                backend_pid=$(pidof ft_full)
                if [ "" = "$backend_pid" ]; then 
                    rm -fr ${PROJECT_CC_WORKER_DIR}/tests/ft_full.log 
                    printVerbose "Starting controller: 'sudo ./ft_full/ft_full'" >ft_full.log
                    # Cleaning up before.
                    printVerbose "sudo rm -rvf /tmp/cmon*"
                    sudo rm -rvf /tmp/cmon*
                    ls -lh /tmp/cmon*
                    printVerbose "sudo rm -rvf /tmp/BACKUP-*"
                    sudo rm -rvf /tmp/BACKUP-*
                    ls -lh /tmp/BACKUP-*

                    sudo ./ft_full/ft_full >>ft_full.log 2>>ft_full.log &
                    backend_pid=$!
                    printVerbose "Backend PID is ${backend_pid}."
                    printVerbose "Waiting for ft_full to create /tmp/cmon_test/usermgmt.fifo"

                    for delay in $(seq 1 100); do
                        if [ -e "/tmp/cmon_test/usermgmt.fifo" ]; then
                            break
                        fi

                        sleep 3
                    done
                else
                    printVerbose "ft_full is already running"
                    printVerbose "Backend PID is ${backend_pid}."
                    printVerbose "PID won't be stored, so ft_full won't be stopped."
                    backend_pid=""
                fi
            else
                printVerbose "The ft_full/ft_full was not found."
                save_slog_file
                return 1
            fi

            changedir "${PROJECT_S9S_TESTORIGIN_DIR}/tests"

            if [ ! -f "$OPTION_TEST_NAME" ]; then
                printVerbose "Program $OPTION_TEST_NAME was not found in $PWD"
                return 1
            fi

            # 
            # Running the test script itself.
            # 
            printVerbose "Running '$OPTION_TEST_NAME'..."
            save_slog_file
            printVerbose "timeout --kill-after=92m 90m ./$OPTION_TEST_NAME \
                --print-commands --reset-config --server=$(hostname) \
                \>\>$logfile 2\>\>$logfile"

            pip-host-control --testing --status="Running $OPTION_TEST_NAME"

            timeout --kill-after=92m 90m ./$OPTION_TEST_NAME \
                --print-commands \
                --reset-config \
                --server=$(hostname) \
                $OPTION_KEEP_NODES \
                >>"$logfile" 2>>"$logfile" &

            test_pid=$!
            printVerbose "Test script PID is ${test_pid}."

            #
            # Starting a watcher that keeps uploading the output...
            #
            upload_result_file \
                --functional-test \
                --pid "$test_pid" \
                "RUNNING"
            
            watcher_pid=$!
            printVerbose "Watcher PID is ${watcher_pid}."
            save_slog_file

            #
            # Waiting for the test to be ended.
            #
            printVerbose "Waiting until the test script ends..."
            wait "$test_pid" 2>/dev/null
            return_code=$?

            printVerbose "Finished ${OPTION_TEST_NAME} ($return_code)."

            printVerbose "Waiting for test watcher to end..."
            wait "$watcher_pid" 2>/dev/null

            changedir "${PROJECT_CC_WORKER_DIR}/tests"

            ft_test_ended \
                "$return_code" \
                "$backend_pid" \
                >>ft_full.log 2>>ft_full.log
            
            #
            # Cleaning up after.
            #
            if [ "$backend_pid" != "" ]; then
                printVerbose "Stopping the ft_full backend."
                sudo kill $backend_pid
                sleep 3
                sudo kill -9 $backend_pid
                sleep 3
                sudo pkill ft_full
                sleep 3
                sudo pkill -9 ft_full
                #sudo rm -rvf /tmp/cmon*
                #sudo rm -rvf /tmp/BACKUP-*
            fi

            if [ $return_code -eq 0 ]; then
                upload_result_file \
                    --functional-test \
                    "SUCCESS"
            else
                upload_result_file \
                    --functional-test \
                    "FAILURE"
            fi
            ;;

        ft_*)
            changedir "${PROJECT_CC_WORKER_DIR}/tests"

            if [ -f "Vagrantfile" ]; then
                vagrant destroy -f
                rm -f "Vagrantfile"
            fi

            rm -f test_ssh_key.pub*
            rm -fr ft_full.log 

            printVerbose "Running ${OPTION_TEST_NAME}."

            if [ ! -f "$OPTION_TEST_NAME/$OPTION_TEST_NAME" ]; then
                printVerbose "Program $OPTION_TEST_NAME was not found."

                return 1
            fi

            pip-host-control --testing --status="Running $OPTION_TEST_NAME"
            printVerbose "Running $OPTION_TEST_NAME."
            ./$OPTION_TEST_NAME/$OPTION_TEST_NAME \
                --template=headless \
                $VENDOR_OPTION \
                $VERSION_OPTION \
                $OS_OPTION >>"$logfile" 2>>"$logfile" &

            test_pid=$!
            
            upload_result_file \
                --functional-test \
                --pid "$test_pid" \
                "RUNNING"

            watcher_pid=$!
            wait "$test_pid"
            return_code=$?

            printVerbose "Finished ${OPTION_TEST_NAME} ($return_code)."
            
            ft_test_ended \
                "$return_code" \
                "" # \ >>ft_full.log 2>>ft_full.log

            if [ $return_code -eq 0 ]; then
                upload_result_file \
                    --functional-test \
                    "SUCCESS"
            else
                upload_result_file \
                    --functional-test \
                    "FAILURE"
            fi
            ;;

        ut_s9s*)
            #
            # This is under development.
            #
            changedir "${PROJECT_S9S_WORKER_DIR}/tests"

            upload_result_file \
                --unit-test \
                "RUNNING"

            #
            # Running the test.
            #
            printVerbose "Running $OPTION_TEST_NAME."
            printVerbose "$OPTION_TEST_NAME/$OPTION_TEST_NAME >>$logfile 2>>$logfile"

            if [ ! -f "$OPTION_TEST_NAME/$OPTION_TEST_NAME" ]; then
                printVerbose "File $OPTION_TEST_NAME/$OPTION_TEST_NAME not found in ${PWD}."
                
                upload_result_file \
                    --unit-test \
                    "FAILURE"

                return 1
            fi

            printVerbose "Running $OPTION_TEST_NAME."

            pip-host-control --testing --status="Running $OPTION_TEST_NAME"

            $OPTION_TEST_NAME/$OPTION_TEST_NAME --color >>$logfile 2>>$logfile
            return_code=$?

            printVerbose "Finished ${OPTION_TEST_NAME} ($return_code)."
            if [ $return_code -eq 0 ]; then
                upload_result_file \
                    --unit-test \
                    "SUCCESS"
            else
                upload_result_file \
                    --unit-test \
                    "FAILURE"
            fi
            ;;

        *)
            printVerbose "Unhandled test name '${OPTION_TEST_NAME}'."
    esac

    printVerbose "Finished running '$OPTION_TEST_NAME' ($return_code)."
    save_slog_file
}

function install_packages_on_test_server()
{
    pip-host-control --testing --status="Started host for $OPTION_TEST_NAME"

    if [ -z "$(psql --version)" ]; then
        printVerbose "Installing postgresql..."
        sudo apt-get -y --force-yes install postgresql
    fi

    if [ -z "$(bc --version)" ]; then
        printVerbose "Installing bc..."
        sudo apt-get -y --force-yes install bc
    fi

    if [ ! -f "/usr/include/hiredis/hiredis.h" ]; then
        printVerbose "Installing hiredis..."
        sudo apt-get -y --force-yes install libhiredis-dev
    fi
}

#
function main()
{
    printVerbose "Starting main()."
    printVerbose "Preparing test ($MYNAME ver. $VERSION)."
    pip-host-control --testing --status="Prepare host for $OPTION_TEST_NAME"

    install_packages_on_test_server

    #
    # Finding the source root.
    #
    if [ ! -d "${PROJECT_CC_WORKER_DIR}" ]; then
        printError "Directory '${PROJECT_CC_WORKER_DIR}' does not exist."
        return 6
    fi
    
    rm -f "${PROJECT_CC_WORKER_DIR}/*.log"
    rm -f "${PROJECT_CC_WORKER_DIR}/tests/*.log"

    #
    # If the user removes this file we cancel the shutdown request, otherwise we
    # will shut down the server at the end of the test.
    #
    if [ "$SHUT_DOWN_AFTER" ]; then
        if [ -z "$DRY" ]; then
            touch ~/cmontest_will_shut_down
        fi
    fi

    #
    # Preparing the clustercontrol source, generating a file holding the test 
    # results.
    #
    changedir "${PROJECT_CC_WORKER_DIR}"

    prepare_source \
        --package-name      "clustercontrol" \
        --requested-branch  "$OPTION_GIT_BRANCH" \
        --requested-commit  "$OPTION_GIT_COMMIT"

    GIT_HASH=$(git log -n 1 --pretty=format:"%H")
    GIT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
    if [ "$GIT_BRANCH" = "HEAD" ]; then
        GIT_BRANCH="$OPTION_GIT_BRANCH"
    fi
    GIT_COMMIT_DATE=$(git show -s --format=%ci $GIT_HASH)
    GIT_AUTHOR=$(git log -n 1 --pretty=format:"%aE")
    GIT_SUBJECT=$(git log -n 1 --pretty=format:"%s")

    printVerbose "Preliminary test result file: $(result_file_name)"
    generate_test_result_info \
        --test-state "PREPARING" \
        > "${PROJECT_TEST_REPORT_DIR}/$(result_file_name)"

    compile_source
    ret_code=$?
    if [ $ret_code -ne 0 ]; then
        printVerbose "3487 Failed to compile source."

        printVerbose "Environment: $(env)"
        printVerbose "Sudo environment: $(sudo env)"

        generate_test_result_info \
            --test-state "FAILURE" \
            > "${PROJECT_TEST_REPORT_DIR}/$(result_file_name)"

        save_slog_file
        return $ret_code
    fi

    #
    # Running the test.
    #
    run_test

    printVerbose "Finished with tests, idle."

    #
    # If the "shutdown after the test" is requested and the user did not delete
    # the shutdown file we will now shut down the computer.
    #
    if [ "$SHUT_DOWN_AFTER" -a -f ~/cmontest_will_shut_down ]; then
        rm -f ~/cmontest_will_shut_down
        pip-host-control --shutdown
    fi
}

#checkOtherInstances
#printVerbose "checkOtherInstances : $?"
pip-host-control --testing --status="Started with $OPTION_TEST_NAME"
main
RET=$?
pip-host-control --idle --status="Idle after $OPTION_TEST_NAME"
exit $RET

