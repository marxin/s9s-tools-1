#! /bin/bash

MYNAME=$(basename $0)
MYDIR=$(dirname $0)
MYDIR=$(readlink -m $MYDIR)
VERSION="0.0.7"
VERBOSE=""
LOGFILE="$HOME/$MYNAME.log"
EXITCODE=0
COMMAND_LINE_OPTIONS="$0 $*"

GIT_HASH=""
GIT_BRANCH=""
GIT_AUTHOR=""
GIT_SUBJECT=""
START_EPOCH_TIME="$(date +%s)"

NO_GIT_PULL=""
OPTION_NO_COMPILE=""
OPTION_OS="ubuntu"
OPTION_KEEP_NODES=""
DO_CLEAN=""

SHUT_DOWN_AFTER=""

OPTION_TEST_NAME=""
OPTION_VENDOR=""
OPTION_VERSION="0.0"
OPTION_USER="$USER"
OPTION_GIT_BRANCH=""
OPTION_GIT_COMMIT=""

current_test_name=""

declare -A REMOTE_SERVER_STATE

if [ -f "$MYDIR/load_config.sh" ]; then
    source $MYDIR/load_config.sh
else
    echo "File $MYDIR/load_config.sh was not found." >&2
    exit 5
fi

LOGFILE="$PROJECT_LOGDIR/$MYNAME.log"
echo "" >$LOGFILE

source $MYDIR/utilityfunctions.sh

if [ "${PROJECT_AUTO_PULL_WORKER}" != "true" ]; then
    NO_GIT_PULL="true"
fi

function printHelpAndExit()
{
cat <<EOF

Usage:
  $MYNAME [OPTION]...

  $MYNAME - Runs Cmon tests on multiple servers.

  -h, --help              Print this help and exit.
  -v, --version           Print version information and exit.
  --verbose               Print more messages.
  --log-file=FILE         Store all the messages in the given file too.
 
  --user=USERNAME         The name of the user requested the test.

  --pid                   Print the PID of the test script if it is running.
  
  --no-git-pull           Do not execute 'git pull' before the test.
  --no-compile            Do not compile the source, use as it is.
  --keep-nodes            Pass --keep-nodes to tests not to destroy containers.
  --shut-down-after       Shut down the test server after the test.
  --git-branch=BRANCH     The git branch to test.
  --git-commit=HASH       The git commit to test.

  --s9s                   Test the s9s project.
  --test=NAME             The name of the test to run.

  --sqlversion=VERSION    The version to test.
  --vendor=VENDOR         The vendor name to test.
  --os=OS                 The name of the OS to test.

EXAMPLE:
  $MYNAME --server=blade01 --os=debian8 --vendor=mariadb --sqlversion=5.6

EOF

  exit 0
}

ARGS=$(\
    getopt \
        -o hvj: \
        -l "help,verbose,version,log-file:,user:,server:,\
pid,\
test:,unit-tests,functional-tests,os:,vendor:,sqlversion:,s9s,\
no-git-pull,no-compile,keep-nodes,shut-down-after,wait,git-branch:,git-commit:" \
        -- "$@")

if [ $? -ne 0 ]; then
    exit 6
fi

eval set -- "$ARGS"
while true; do
    case "$1" in
        -h|--help)
            shift
            printHelpAndExit
            ;;

        --verbose)
            shift
            VERBOSE="true"
            VERBOSE_OPTION="--verbose"
            ;;

        -v|--version)
            shift
            printVersionAndExit
            ;;

        --log-file)
            shift
            LOGFILE=$(readlink -m "$1")
            shift
            ;;

        --keep-nodes)
            shift
            OPTION_KEEP_NODES="--keep-nodes"
            ;;

        --user)
            shift
            OPTION_USER="$1"
            shift
            ;;

        --test)
            shift
            OPTION_TEST_NAME="$1"
            shift
            ;;

        --os)
            shift
            OPTION_OS="$1"
            shift
            ;;

        --vendor)
            shift
            OPTION_VENDOR="$1"

            shift
            ;;
            
        --sqlversion)
            shift
            OPTION_VERSION="$1"
            shift
            ;;

        --no-git-pull)
            shift
            NO_GIT_PULL="true"
            ;;

        --no-compile)
            shift
            OPTION_NO_COMPILE="true"
            ;;

        --shut-down-after)
            shift
            SHUT_DOWN_AFTER="true"
            ;;

        --wait)
            shift
            WAIT_OPTION="--wait"
            ;;

        --git-branch)
            OPTION_GIT_BRANCH="$2"
            shift 2
            ;;

        --git-commit)
            OPTION_GIT_COMMIT="$2"
            shift 2
            ;;

        --)
            shift
            break
            ;;

        *)
            printVerbose "Unhandled option $1"
            printError "Unhandled option $1"
            exit 1
            ;;
    esac
done

#
# This is how we log from this script. Every run truncates the log file.
#
printVerbose "Starting test runner script..."
printVerbose "             TEST HOST: $(hostname)"
printVerbose "                MYNAME: $MYNAME"
printVerbose "                 MYDIR: $MYDIR"
printVerbose "  COMMAND_LINE_OPTIONS: $COMMAND_LINE_OPTIONS"
printVerbose "           TEST SERVER: $PROJECT_SERVER"
printVerbose "       TEST_REPORT_DIR: $PROJECT_TEST_REPORT_DIR"
printVerbose "     OPTION_GIT_BRANCH: $OPTION_GIT_BRANCH"
printVerbose "     OPTION_GIT_COMMIT: $OPTION_GIT_COMMIT"

function changedir()
{
    local dir=$1
    printVerbose "cd $dir"
    cd $dir > /dev/null 2> /dev/null
    if [ $? -ne 0 ]; then
        printVerbose "Failed to change directory to $dir."
        return 1
    fi
    return 0
}

function pushdir()
{
    local dir=$1
    printVerbose "pushd $dir"
    pushd $dir > /dev/null 2> /dev/null
    if [ $? -ne 0 ]; then
        printVerbose "Failed to change directory to $dir."
        return 1
    fi
    return 0
}

function popdir()
{
    dir=$(popd > /dev/null 2> /dev/null)
    if [ $? -ne 0 ]; then
        printVerbose "Failed to popd."
        return 1
    fi
    printVerbose "popd to $PWD"
    return 0
}

#
# $1: test name
#
function result_file_name_base()
{
    local test_name=$1
    echo "${test_name}-${GIT_BRANCH}-${GIT_HASH}"
    #echo "${OPTION_USER}-$(hostname)-${test_name}-${GIT_HASH}"
}

#
# The basename of the pip-cmon-test log file on the server.
#
function script_log_file_name()
{
    echo "$(result_file_name_base ${OPTION_TEST_NAME}).slog"
}

#
# Uploads the log file of this script to the web server.
#
function upload_slog_file()
{
    local localfile="$HOME/pip-cmon-test.log"
    local remotefile="$(script_log_file_name)"

    if [ -f "$localfile" ]; then
        cp "$localfile" "/tmp/$remotefile"
    else
        touch "/tmp/$remotefile"
    fi
        
    #printVerbose "scp \"/tmp/$remotefile\" \"$PROJECT_SERVER:$PROJECT_TEST_REPORT_DIR\""
    #scp "/tmp/$remotefile" "$PROJECT_SERVER:$PROJECT_TEST_REPORT_DIR"
    rm -f "/tmp/$remotefile"
}

#
# Prints the name of the vendor to test.
#
function vendor_to_test()
{
    local host_name=$(hostname)

    #
    # Command line overrules everything.
    #
    if [ "$OPTION_VENDOR" ]; then
        echo "$OPTION_VENDOR"
        return 0
    fi

    echo "codership"
}

function print_title()
{
    echo "<h3>$*</h3>"
}

#
# This expects to be in the source directory.
#
function prepare_source()
{
    local package_name="unknown"
    local current_branch
    local requested_branch
    local requested_commit
    local prompt="$USER@$HOSTNAME:$dirname\$"

    while [ -n "$1" ]; do
        case "$1" in 
            --package-name)
                package_name=$2
                shift 2
                ;;

            --requested-branch)
                requested_branch="$2"
                shift 2
                ;;

            --requested-commit)
                requested_commit="$2"
                shift 2
                ;;

            *)
                break
                ;;
        esac
    done

    if [ -z "$NO_GIT_PULL" ]; then
        printVerbose "Pulling source for $package_name."
        
        printVerbose "Pulling in directory '${PWD}'"
        git reset --hard HEAD >/dev/null 2>/dev/null
        git pull >/dev/null 2>/dev/null

        #
        # Checking the branch.
        #
        current_branch=$(git rev-parse --abbrev-ref HEAD)
        printVerbose "Current branch is '$current_branch'."
       
        if [ -z "$requested_branch" ]; then
            printVerbose "Requested branch is not set, using 'master'."
            requested_branch="master"
        else 
            printVerbose "Requested branch is '$requested_branch'."
        fi

        #if [ "$current_branch" != "$requested_branch" ]; then
        #    printVerbose "$prompt git checkout $requested_branch"
        #    git checkout "$requested_branch" >>$LOGFILE 2>>$LOGFILE
        #fi
        
        printVerbose "$prompt git fetch --all"
        git fetch --all >>$LOGFILE 2>>$LOGFILE

        # always reset any local changes first, then go to master
        printVerbose "$prompt git reset --hard"
        git reset --hard >>$LOGFILE 2>>$LOGFILE

        printVerbose "$prompt git checkout master"
        git checkout master >>$LOGFILE 2>>$LOGFILE

        if [ "$requested_branch" != "master" ]; then
            # first delete any local branch with the same name
            # (as the remote branch might be overwritten from stratch)
            printVerbose "$prompt git branch -d $requested_branch"
            git branch -d $requested_branch >>$LOGFILE 2>>$LOGFILE

            # and lets check out the branch now
            # (it will be re-constructed from remote)
            printVerbose "$prompt git checkout $requested_branch"
            git checkout $requested_branch >>$LOGFILE 2>>$LOGFILE
        fi

        printVerbose "$prompt git pull"
        printVerbose "Pulling in directory '${PWD}'"
        git pull >>$LOGFILE 2>>$LOGFILE

        if [ ! -z "$requested_commit" ]; then
            printVerbose "$prompt git checkout $requested_commit"
            git checkout $requested_commit >>$LOGFILE 2>>$LOGFILE
        fi

        # Files are left everywhere... :(
        if [ -d "./tests/configs/tls" ]; then
            rm -rvf "./tests/configs/tls"
        fi
    fi

    if [ "$DO_CLEAN" ]; then
        printVerbose "Cleaning source dir."

        git clean -dfx >/dev/null 2>/dev/null
    fi
}

function find_mysql()
{
    for dir in /opt/mysql-cluster-gpl-7*; do
        if [ -d "$dir" ]; then
            echo "$dir"
            return 0
        fi
    done

    return 1
}

#
# Expects to be in the source directory.
#
function compile_source_dir()
{
    local mysql_dir=$(find_mysql)    
    local do_install
    local prefix_option=""
    local cmon=false

    while [ -n "$1" ]; do
        case "$1" in 
            --prefix)
                prefix_option="--prefix=$2"
                shift 2
                ;;

            --cmon-compilation)
                cmon=true
                shift
                ;;

            --install)
                do_install="true"
                shift
                ;;

            *)
                break
                ;;
        esac
    done

    if [ "$mysql_dir" ]; then
        export PATH="$mysql_dir/bin:$PATH"
    fi

    upload_slog_file

    #
    # Not gonna compile the source when the --no-compile command line option is
    # provided.
    #
    if [ "$OPTION_NO_COMPILE" ]; then
        return 0
    fi

    #
    # Hack to avoid compilation
    #
    if [ cmon ]; then
        case "$OPTION_TEST_NAME" in 
            ft_*.sh)
                repodir="$HOME/ft_full_repo/$OPTION_GIT_BRANCH-$OPTION_GIT_COMMIT"
                ccdir="${PROJECT_CC_WORKER_DIR}"

                if [ -d "$repodir" ]; then
                    printVerbose "Using previously compiled ft_full from $repodir"
                    cp $repodir/ft_full $ccdir/tests/ft_full/
                    return
                fi
            ;;
            *)
                # Nothing to do here
            ;;
        esac
    fi

    #
    # Running autogen in the source root. 
    #
    if [ ! -f "Makefile" ]; then
        printVerbose "Running autogen.sh."

        rm -f autogen.log

        if [ cmon ]; then
            ./autogen.sh --with-no-optimization $prefix_option >> "autogen.log" 2>>"autogen.log"
        else
            ./autogen.sh $prefix_option >> "autogen.log" 2>>"autogen.log"
        fi
        retcode $?
        if [ $retcode -ne 0 ]; then
            printVerbose "Script autogen.sh failed."
            return 6
        fi
    fi
    
    #
    # Running make in source root.
    #
    printVerbose "Running 'make'."

    rm -f "make.log"

    make -j10 >>"make.log" 2>>"make.log"
    retcode=$?
    make -j10
    if [ "$retcode" -ne 0 ]; then
        printVerbose "Program 'make' failed."
        tail -n 50 "$PWD/make.log" >>$LOGFILE

        return 1
    fi

    if [ -n "$do_install" ]; then
        printVerbose "Running 'make install'."

        sudo make install >>"make.log" 2>>"make.log"

        if [ $? -ne 0 ]; then
            printVerbose "Installing with 'make install' failed."
            return 1
        fi
    fi

    #
    # Hack to cache ft_full avoid compilation next time
    #
    if [ cmon ]; then
        case "$OPTION_TEST_NAME" in 
            ft_*.sh)
                repodir="$HOME/ft_full_repo/$OPTION_GIT_BRANCH-$OPTION_GIT_COMMIT"
                ccdir="${PROJECT_CC_WORKER_DIR}"

                mkdir -p "$repodir"
                printVerbose "Saving ft_full to $repodir"
                cp $ccdir/tests/ft_full/ft_full $repodir/
            ;;
            *)
                # Nothing to do here
            ;;
        esac
    fi

    return 0
}

function compile_source()
{
    local retcode

    printVerbose "Preparing clustercontrol"

    #
    # Compiling the controller.
    # The source is already prepared in advance.
    #

    pip-host-control --testing --status="Compiling CC for $OPTION_TEST_NAME"

    changedir "${PROJECT_CC_WORKER_DIR}"
    compile_source_dir \
        --cmon-compilation

        #--prefix=$HOME/testcmon
        #--prefix=$HOME/cmonrepo/$GIT_BRANCH-$GIT_HASH

    retcode=$?
    
    if [ "$retcode" -ne 0 ]; then
        printVerbose "The return code is $retcode..."
        return "$retcode"
    fi

    #
    # Compiling the s9s-tools, the source is not yet prepared.
    #

    pip-host-control --testing --status="Compiling s9s for $OPTION_TEST_NAME"

    changedir "${PROJECT_S9S_WORKER_DIR}"
    prepare_source \
        --package-name "s9s-tools"

    compile_source_dir \
        --install 

        #--prefix=$HOME/tests9s

    retcode="$?"

    return "$retcode"
}

#
# $1: test name
#
# The report is a HTML file where we put the report about the test run.
#
function report_file_name()
{
    local test_name=$1
    echo "$(result_file_name_base $test_name).html"
}

function result_file_name()
{
    local test_name=$1
    echo "$(result_file_name_base $test_name).result"
}

function log_bin_file_name()
{
    local test_name=$1
    echo "$(result_file_name_base $test_name).ft_full"
}

function log_core_file_name()
{
    local test_name=$1
    echo "$(result_file_name_base $test_name).core"
}

function log_file_name()
{
    local test_name=$1
    echo "$(result_file_name_base $test_name).log"
}

function ft_test_ended()
{
    local exit_code="$1"
    local backend_pid="$2"
    local core_file

    #printVerbose "<h2>Backtrace</h2>" 

    printVerbose "The test ended."
    printVerbose "  exit_code: $exit_code"
    printVerbose "         wd: '$PWD'"

    pip-host-control --testing --status="Finishing $OPTION_TEST_NAME"

    #for core_file in \
    #    *core* \
    #    */*core* \
    #    ${PROJECT_CC_WORKER_DIR}/*core* \
    #    ${PROJECT_CC_WORKER_DIR}/tests/*core* \
    for core_file in \
        /tmp/*.core;
    do
        if [ ! -f "$core_file" ]; then
            continue
        fi

        printVerbose "Core file found: $core_file"
    done

    if [ ! -f "$core_file" -a "$exit_code" -eq 0 ]; then
        return 0
    fi

    if [ -z "$(which gdb)" ]; then
        printVerbose "Installing gdb."
        sudo apt-get -y --force-yes install gdb
    fi

    if [ -e "$core_file" ]; then
        printVerbose "Saving backtrace (crash)"
        sudo gdb \
            -batch \
            -ex "thread apply all back" \
            -ex "quit" \
            ft_full/ft_full "$core_file" \
            >>$LOGFILE 2>>$LOGFILE

        sudo mkdir -p "$HOME/tmp"

        sudo mv "$core_file" "$HOME/tmp/$(log_core_file_name $OPTION_TEST_NAME)"
        #scp "$HOME/tmp/$(log_core_file_name $OPTION_TEST_NAME)" "${PROJECT_SERVER:$PROJECT_TEST_REPORT_DIR}"
        #sudo rm "$HOME/tmp/$(log_core_file_name $OPTION_TEST_NAME)"
        chown $PROJECT_OWNER:$PROJECT_OWNER \
            "${PROJECT_SERVER:$PROJECT_TEST_REPORT_DIR}/$(log_core_file_name $OPTION_TEST_NAME)"

        sudo mv "${PROJECT_CC_WORKER_DIR}/tests/ft_full/ft_full" \
                "$HOME/tmp/$(log_bin_file_name $OPTION_TEST_NAME)"
        #scp "$HOME/tmp/$(log_bin_file_name $OPTION_TEST_NAME)" "${PROJECT_SERVER:$PROJECT_TEST_REPORT_DIR}"
        sudo rm "$HOME/tmp/$(log_bin_file_name $OPTION_TEST_NAME)"
        chown $PROJECT_OWNER:$PROJECT_OWNER \
            "${PROJECT_SERVER:$PROJECT_TEST_REPORT_DIR}/$(log_bin_file_name $OPTION_TEST_NAME)"

    elif [ -n "$backend_pid" -a "$exit_code" -ne 0 ]; then
        printVerbose "Saving backtrace (no crash)"
        sudo gdb \
            -p $backend_pid -batch \
            -ex "thread apply all back" \
            -ex "quit" \
            >>$LOGFILE 2>>$LOGFILE
    else
        printVerbose "No backtrace is necessary. No rash, no error on exit."
    fi
}

#
# $1: test name
# $2: the state, "FAILURE", "RUNNING" or "SUCCESS"
# $3: file with the test program output
#
function upload_report_file_ascii()
{
    local report_file=$(report_file_name "$1")
    local tmp_file="/var/tmp/$report_file"

    cat <<EOF >>$tmp_file
    <html>
      <h1>Test results for '$1'</h1>
      <p>This test created no report. Try to check the programs output for
      details. The web interface shows the output when clicked on the test's
      name.</p>
    </html>
EOF

    #printVerbose scp "$tmp_file" "$PROJECT_SERVER:$PROJECT_TEST_REPORT_DIR"
    #scp "$tmp_file" "$PROJECT_SERVER:$PROJECT_TEST_REPORT_DIR"
    rm -f "$tmp_file"
}

#
# $1: test name
# $2: the state, "FAILURE", "RUNNING" or "SUCCESS"
# $3: file with the test program output
#
function upload_result_file()
{
    local test_name
    local test_state
    local result_file
    local log_file
    local tmp_file
    local unit_test_option
    local functional_test_option
    local pid_to_watch
    local counter

    while true; do
        case "$1" in 
            --unit-test)
                shift
                unit_test_option="--unit-test"
                ;;

            --functional-test)
                shift
                functional_test_option="--functional-test"
                ;;

            --pid)
                shift
                pid_to_watch="$1"
                shift
                ;;

            *)
                break
        esac
    done

    test_name="$1"
    test_state="$2"
    result_file=$(result_file_name "$test_name")
    log_file=$(log_file_name "$test_name")
    daemon_log_file="$(basename "$log_file" .log).dlog"
    tmp_file="/var/tmp/$result_file"


    #
    # If we have a PID we do the uploading until that ends. If not, we just
    # upload once.
    #
    counter=0

    while true; do
        if [ -f "$log_file" ]; then
            #printVerbose scp "$log_file" "$PROJECT_SERVER:$PROJECT_TEST_REPORT_DIR"
            #scp "$log_file" "$PROJECT_SERVER:$PROJECT_TEST_REPORT_DIR"
            true
        fi

        upload_report_file_ascii \
            "$test_name"  "$test_state" "$3"

        generate_test_result_info \
            $unit_test_option \
            $functional_test_option \
            --test-name  "$test_name" \
            --test-state "$test_state" \
            >$tmp_file

        #printVerbose scp "$tmp_file" "$PROJECT_SERVER:$PROJECT_TEST_REPORT_DIR"
        #scp "$tmp_file" "$PROJECT_SERVER:$PROJECT_TEST_REPORT_DIR"

        if [ -z "$unit_test_option" -a \
            -f "${PROJECT_CC_WORKER_DIR}/tests/ft_full.log" ]; then
            #printVerbose scp \
            #    "${PROJECT_CC_WORKER_DIR}/tests/ft_full.log" \
            #    "$PROJECT_SERVER:$PROJECT_TEST_REPORT_DIR/$daemon_log_file"
            #scp \
            #    "${PROJECT_CC_WORKER_DIR}/tests/ft_full.log" \
            #    "$PROJECT_SERVER:$PROJECT_TEST_REPORT_DIR/$daemon_log_file"
            true
        fi

        if [ -z "$pid_to_watch" ]; then
            break
        fi

        if ! ps --pid $pid_to_watch; then
            break
        fi

        # We are not gonna run indefinitely, that is a huge disaster.
        let counter+=10
        if [ $counter -gt 5400 ]; then
            printVerbose "One and a half hour elapsed, the watcher will abort now."
            break
        fi

        sleep 10
    done

    rm -f "$tmp_file"
}

function elapsedTimeString()
{
    local start_date="$1"
    local end_date="$(date +%s)"
    local T=$((end_date-start_date))

    printf "%02d:%02d:%02d" \
        "$((T/3600%24))" "$((T/60%60))" "$((T%60))"
}

#
# $1: test name
# $2: the state, "FAILURE", "RUNNING" or "SUCCESS"
#
function generate_test_result_info()
{
    local git_has_local_changes="no"
    local elapsed_time
    local is_unit_test="true"
    local test_name
    local test_state

    while true; do
        case "$1" in 
            --unit-test)
                shift
                is_unit_test="true"
                ;;

            --functional-test)
                shift
                is_unit_test="false"
                ;;

            --test-name)
                shift
                test_name="$1"
                shift
                ;;

            --test-state)
                shift
                test_state="$1"
                shift
                ;;

            *)
                break
        esac
    done

    git_has_local_changes="no"

    if ! git diff-index --quiet HEAD --; then 
        git_has_local_changes="yes"
    fi

    elapsed_time="$(date +%s)"
    let elapsed_time-="$START_EPOCH_TIME"

    cat <<EOF
test_server="$(hostname)"
testname="$test_name"
githash="$GIT_HASH"
gitbranch="$GIT_BRANCH"
gitcommitdate="$GIT_COMMIT_DATE"
githaslocalchanges="$git_has_local_changes"
state="$test_state"
report_file="$(report_file_name $test_name)"
user="$OPTION_USER"
elapsed_time="$elapsed_time"
elapsed_time_string="$(elapsedTimeString $START_EPOCH_TIME)"
test_start_epoch="$START_EPOCH_TIME"
is_unit_test="$is_unit_test"
EOF
}

#
# $1: the test name
# $2: the single os name to test
# $3: the single version to test
#
function run_test()
{
    local test_name="$(basename "$1")"
    local os="$2"
    local version="$3"
    local vendor="$(vendor_to_test)"
    local return_code
    local tmp_file
    local logfile
    local scriptlogfile

    current_test_name="$test_name"
    logfile=$(log_file_name "$test_name")

    #
    # Notifying the user about a test is starting.
    #
    printVerbose "Preparing to run $test_name."
    upload_slog_file

    printVerbose "Enabling core file creation."
    echo "core" | sudo tee /proc/sys/kernel/core_pattern >> $LOGFILE 2>> $LOGFILE
    if [ $? -ne 0 ]; then
        printVerbose "Failed: echo 'core' | sudo tee /proc/sys/kernel/core_pattern"
    fi

    for core_file in \
        /tmp/*.core \
        *core* \
        */*core* \
        ${PROJECT_CC_WORKER_DIR}/*core* \
        ${PROJECT_CC_WORKER_DIR}/tests/*core*; 
    do
        if [ ! -f "$core_file" ]; then
            continue
        fi

        rm -f "$core_file"
    done

    ulimit -c unlimited
    if [ $? -ne 0 ]; then
        printVerbose "Failed: ulimit -c unlimited"
    fi

    sudo sysctl -p /etc/sysctl.conf
    printVerbose "Core pattern: $(sudo cat /proc/sys/kernel/core_pattern)"
    printVerbose ""
    printVerbose "User limits :"
    printVerbose ""
    bash -c 'ulimit -a' >> $LOGFILE 2>> $LOGFILE
    printVerbose ""
    printVerbose "User limits with sudo:"
    printVerbose ""
    sudo bash -c 'ulimit -c unlimited' >> $LOGFILE 2>> $LOGFILE
    sudo bash -c 'ulimit -a' >> $LOGFILE 2>> $LOGFILE

    #
    # Running the actual test.
    #
    printVerbose "PWD: $(pwd)"
    printVerbose "Test name is '${test_name}'."
    case "$test_name" in 
        ft_*.sh)
            #
            # Running the ft_full
            #
            export DOWNLOAD_KEYSERVER="hkp://keyserver.ubuntu.com"
            changedir "${PROJECT_CC_WORKER_DIR}/tests"

            if [ -x "./ft_full/ft_full" ]; then
                printVerbose "Running 'ft_full'..."

                printVerbose "Current directory: $(pwd)"
                printVerbose "Sudo environment: $(sudo env)"

                backend_pid=$(pidof ft_full)
                if [ "" == "$backend_pid" ]; then 
                    rm -fr ${PROJECT_CC_WORKER_DIR}/tests/ft_full.log 
                    printVerbose "Starting controller: 'sudo ./ft_full/ft_full'" >ft_full.log
                    # Cleaning up before.
                    printVerbose "sudo rm -rvf /tmp/cmon*"
                    sudo rm -rvf /tmp/cmon*
                    ls -lh /tmp/cmon*
                    printVerbose "sudo rm -rvf /tmp/BACKUP-*"
                    sudo rm -rvf /tmp/BACKUP-*
                    ls -lh /tmp/BACKUP-*

                    sudo ./ft_full/ft_full >>ft_full.log 2>>ft_full.log &
                    backend_pid=$!
                    printVerbose "Backend PID is ${backend_pid}."
                    printVerbose "Waiting for ft_full to create /tmp/cmon_test/usermgmt.fifo"

                    for delay in $(seq 1 100); do
                        if [ -e "/tmp/cmon_test/usermgmt.fifo" ]; then
                            break
                        fi

                        sleep 3
                    done
                else
                    printVerbose "ft_full is already running"
                    printVerbose "Backend PID is ${backend_pid}."
                    printVerbose "PID won't be stored, so ft_full won't be stopped."
                    backend_pid=""
                fi
            else
                printVerbose "The ft_full/ft_full was not found."
                upload_slog_file
                return 1
            fi

            changedir "${PROJECT_S9S_TESTORIGIN_DIR}/tests"

            if [ ! -f "$test_name" ]; then
                printVerbose "Program $test_name was not found in $PWD"
                return 1
            fi

            # 
            # Running the test script itself.
            # 
            printVerbose "Running '$test_name'..."
            upload_slog_file
            printVerbose "timeout --kill-after=92m 90m ./$test_name \
                --print-commands --reset-config --server=$(hostname) \
                \>\>$logfile 2\>\>$logfile"

            pip-host-control --testing --status="Running $OPTION_TEST_NAME"

            timeout --kill-after=92m 90m ./$test_name \
                --print-commands \
                --reset-config \
                --server=$(hostname) \
                $OPTION_KEEP_NODES \
                >>"$logfile" 2>>"$logfile" &

            test_pid=$!
            printVerbose "Test script PID is ${test_pid}."

            #
            # Starting a watcher that keeps uploading the output...
            #
            upload_result_file \
                --functional-test \
                --pid "$test_pid" \
                "$test_name" "RUNNING" $logfile &
            
            watcher_pid=$!
            printVerbose "Watcher PID is ${watcher_pid}."
            upload_slog_file

            #
            # Waiting for the test to be ended.
            #
            printVerbose "Waiting until the test script ends..."
            wait "$test_pid" 2>/dev/null
            return_code=$?

            printVerbose "Finished ${test_name} ($return_code)."

            printVerbose "Waiting for test watcher to end..."
            wait "$watcher_pid" 2>/dev/null

            changedir "${PROJECT_CC_WORKER_DIR}/tests"

            ft_test_ended \
                "$return_code" \
                "$backend_pid" \
                >>ft_full.log 2>>ft_full.log
            
            #
            # Cleaning up after.
            #
            if [ "$backend_pid" != "" ]; then
                printVerbose "Stopping the ft_full backend."
                sudo kill $backend_pid
                sleep 3
                sudo kill -9 $backend_pid
                sleep 3
                sudo pkill ft_full
                sleep 3
                sudo pkill -9 ft_full
                #sudo rm -rvf /tmp/cmon*
                #sudo rm -rvf /tmp/BACKUP-*
            fi

            if [ $return_code -eq 0 ]; then
                upload_result_file \
                    --functional-test \
                    "$test_name" "SUCCESS" $logfile
            else
                upload_result_file \
                    --functional-test \
                    "$test_name" "FAILURE" $logfile
            fi
            ;;

        ft_*)
            changedir "${PROJECT_CC_WORKER_DIR}/tests"

            if [ -f "Vagrantfile" ]; then
                vagrant destroy -f
                rm -f "Vagrantfile"
            fi

            rm -f test_ssh_key.pub*
            rm -fr ft_full.log 

            printVerbose "Running ${test_name}."

            if [ ! -f "$test_name/$test_name" ]; then
                printVerbose "Program $test_name was not found."

                return 1
            fi

            version_option=
            if [ "$version" != "" ]; then
                if [ "$version" != "0.0" ]; then
                    version_option="--provider-version=$version"
                fi
            fi
            pip-host-control --testing --status="Running $OPTION_TEST_NAME"
            printVerbose "Running $test_name."
            ./$test_name/$test_name \
                --template=headless \
                --vendor="$(vendor_to_test)" \
                $version_option \
                --os="$os" >>"$logfile" 2>>"$logfile" &

            test_pid=$!
            
            upload_result_file \
                --functional-test \
                --pid "$test_pid" \
                "$test_name" "RUNNING" $logfile 

            watcher_pid=$!
            wait "$test_pid"
            return_code=$?

            printVerbose "Finished ${test_name} ($return_code)."
            
            ft_test_ended \
                "$return_code" \
                "" # \ >>ft_full.log 2>>ft_full.log

            if [ $return_code -eq 0 ]; then
                upload_result_file \
                    --functional-test \
                    "$test_name" "SUCCESS" $logfile
            else
                upload_result_file \
                    --functional-test \
                    "$test_name" "FAILURE" $logfile
            fi
            ;;

        ut_s9s*)
            #
            # This is under development.
            #
            changedir "${PROJECT_S9S_WORKER_DIR}/tests"

            upload_result_file \
                --unit-test \
                "$test_name" "RUNNING" $logfile

            #
            # Running the test.
            #
            printVerbose "Running $(basename $test_name)."
            printVerbose "$test_name/$test_name >>$logfile 2>>$logfile"

            if [ ! -f "$test_name/$test_name" ]; then
                printVerbose "File $test_name/$test_name not found in ${PWD}."
                
                upload_result_file \
                    --unit-test \
                    "$test_name" "FAILURE" $logfile

                return 1
            fi

            printVerbose "Running $test_name."

            pip-host-control --testing --status="Running $OPTION_TEST_NAME"

            $test_name/$test_name --color >>$logfile 2>>$logfile
            return_code=$?

            printVerbose "Finished ${test_name} ($return_code)."
            if [ $return_code -eq 0 ]; then
                upload_result_file \
                    --unit-test \
                    "$test_name" "SUCCESS" $logfile
            else
                upload_result_file \
                    --unit-test \
                    "$test_name" "FAILURE" $logfile
            fi
            ;;

        *)
            printVerbose "Unhandled test name '${test_name}'."
    esac
   
    #
    # Uploading the output of the test program as log file.
    #
    if [ -f "$logfile" ]; then
        #printVerbose "scp \"$logfile\" \"$PROJECT_SERVER:$PROJECT_TEST_REPORT_DIR\""
        #scp "$logfile" "$PROJECT_SERVER:$PROJECT_TEST_REPORT_DIR"
        rm -f "$logfile"
    fi
            
    printVerbose "Finished running '$test_name' ($return_code)."
    upload_slog_file
}

function install_packages_on_test_server()
{
    pip-host-control --testing --status="Started host for $OPTION_TEST_NAME"

    if [ -z "$(psql --version)" ]; then
        printVerbose "Installing postgresql..."
        sudo apt-get -y --force-yes install postgresql
    fi

    if [ -z "$(bc --version)" ]; then
        printVerbose "Installing bc..."
        sudo apt-get -y --force-yes install bc
    fi

    if [ ! -f "/usr/include/hiredis/hiredis.h" ]; then
        printVerbose "Installing hiredis..."
        sudo apt-get -y --force-yes install libhiredis-dev
    fi
}

#
# $1: os
# $2: test name
# $3: version
#
function main()
{
    local os="$1"
    local name="$2"
    local version="$3"

    printVerbose "Starting main()."
    printVerbose "Preparing test ($MYNAME ver. $VERSION)."
    pip-host-control --testing --status="Prepare host for $OPTION_TEST_NAME"

    install_packages_on_test_server

    #
    # Finding the source root.
    #
    if [ ! -d "${PROJECT_CC_WORKER_DIR}" ]; then
        printError "Directory '${PROJECT_CC_WORKER_DIR}' does not exist."
        return 6
    fi
    
    rm -f "${PROJECT_CC_WORKER_DIR}/*.log"
    rm -f "${PROJECT_CC_WORKER_DIR}/tests/*.log"

    #
    # If the user removes this file we cancel the shutdown request, otherwise we
    # will shut down the server at the end of the test.
    #
    if [ "$SHUT_DOWN_AFTER" ]; then
        if [ -z "$DRY" ]; then
            touch ~/cmontest_will_shut_down
        fi
    fi

    #
    # Preparing the clustercontrol source, generating a file holding the test 
    # results.
    #
    changedir "${PROJECT_CC_WORKER_DIR}"

    prepare_source \
        --package-name      "clustercontrol" \
        --requested-branch  "$OPTION_GIT_BRANCH" \
        --requested-commit  "$OPTION_GIT_COMMIT"

    GIT_HASH=$(git log -n 1 --pretty=format:"%H")
    GIT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
    if [ "$GIT_BRANCH" = "HEAD" ]; then
        GIT_BRANCH="$OPTION_GIT_BRANCH"
    fi
    GIT_COMMIT_DATE=$(git show -s --format=%ci $GIT_HASH)
    GIT_AUTHOR=$(git log -n 1 --pretty=format:"%aE")
    GIT_SUBJECT=$(git log -n 1 --pretty=format:"%s")

    result_file=$(result_file_name "$OPTION_TEST_NAME")
    tmp_file="/var/tmp/$result_file"

    printVerbose "Preliminary test result file: $result_file"
    generate_test_result_info \
        --test-name  "$OPTION_TEST_NAME" \
        --test-state "PREPARING" \
        >$tmp_file

    #printVerbose scp "$tmp_file" "$PROJECT_SERVER:$PROJECT_TEST_REPORT_DIR"
    #scp "$tmp_file" "$PROJECT_SERVER:$PROJECT_TEST_REPORT_DIR"

    compile_source
    ret_code=$?
    if [ $ret_code -ne 0 ]; then
        current_test_name="$OPTION_TEST_NAME"
        
        printVerbose "3487 Failed to compile source."

        printVerbose "Environment: $(env)"
        printVerbose "Sudo environment: $(sudo env)"

        generate_test_result_info \
            --test-name  "$OPTION_TEST_NAME" \
            --test-state "FAILURE" \
            >$tmp_file

        #printVerbose scp "$tmp_file" "$PROJECT_SERVER:$PROJECT_TEST_REPORT_DIR"
        #scp "$tmp_file" "$PROJECT_SERVER:$PROJECT_TEST_REPORT_DIR"

        upload_slog_file
        return $ret_code
    fi

    #
    # Running the test.
    #
    run_test "$name" "$os" "$version"

    printVerbose "Finished with tests, idle."

    #
    # If the "shutdown after the test" is requested and the user did not delete
    # the shutdown file we will now shut down the computer.
    #
    if [ "$SHUT_DOWN_AFTER" -a -f ~/cmontest_will_shut_down ]; then
        rm -f ~/cmontest_will_shut_down
        pip-host-control --shutdown
    fi
}

#checkOtherInstances
#printVerbose "checkOtherInstances : $?"
pip-host-control --testing --status="Started with $OPTION_TEST_NAME"
main "$OPTION_OS" "$OPTION_TEST_NAME" "$OPTION_VERSION"
RET=$?
pip-host-control --idle --status="Idle after $OPTION_TEST_NAME"
exit $RET

